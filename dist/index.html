<!doctype html><html><head><title>Getting Started</title></head><body><p>In this demo you can select either JPG or WAV files from your local system. Their headers will be read and displayed on the page.</p><p>Have a look at the code (inlined in this page) to see what is going on.</p><p>While the JPG example isn't too exciting (as the web excels at handling these files), the WAV one has a more interesting use case which uses error correction when dealing with a file containing metadata that deviates from the spec.</p><form><fieldset><label for="fileInput">Select a file</label> <input type="file" accept="image/jpeg,audio/wav" id="fileInput"/></fieldset></form><pre>
          <code id="resultArea"></code>
      </pre><script src="typed-file-parser.min.js"></script></body><style>#resultArea {
          width: 250px;
          height: 250px;
      }</style><script type="module">import { types, parseFile, fileToByteArray, parseByteArray, scanUntil } from './src/index.js';
      const { CHAR, INT8, INT16, INT32 } = types;

      // header for JPEG files (see https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format)
      // note Big Endianness being enforced as it is part of the JPEG spec.

      const jpegHeader = {
          startOfImageMarker:   `${INT16}|BE`, // should be 0xffd8
          applicationUseMarker: `${INT16}|BE`, // should be 0xffe0
          length:               INT16,
          identifier:           `${CHAR}[5]`,  // should be "JFIF" with a null byte terminator
          version:              `${INT8}[2]`,  // first byte major, seocond minor version
          densityUnits:         INT8,
          xDensity:             `${INT16}|BE`,
          yDensity:             `${INT16}|BE`,
          xThumbnail:           INT8,
          yThumbnail:           INT8
      };

      // header for WAV files (see http://soundfile.sapp.org/doc/WaveFormat)

      const wavHeader = {
          type:             `${CHAR}[4]`, // should be "RIFF"
          size:             INT32,
          format:           `${CHAR}[4]`, // should be "WAVE"
          formatName:       `${CHAR}[4]`, // should be "fmt " (note empty char!) but can be "JUNK"
          formatLength:     INT32,
          audioFormat:      INT16,
          channelAmount:    INT16,
          sampleRate:       INT32,
          bytesPerSecond:   INT32,
          blockAlign:       INT16,
          bitsPerSample:    INT16,
          dataChunkId:      `${CHAR}[4]`, // should be "data"
          dataChunkSize:    INT32
      };

      // cached DOM elements and convenience methods

      const resultArea = document.querySelector( "#resultArea" );
      const formatJson = json => JSON.stringify( json, ( name, val ) => typeof val === "string" ? val.replace( /\u0000/g, "" ) : val, 2 );

      // attach listener to file input and actual demo !

      document.querySelector( "#fileInput" ).addEventListener( "input", async event => {
          // get file from input event
          const { files } = event.target;
          const file      = files[ 0 ];

          if ( file.type === "image/jpeg" ) {
              // EXAMPLE 1: file is JPEG image
              const { data, error } = await parseFile( file, jpegHeader );
              resultArea.innerText = error ? "An error has occurred during file parsing" : formatJson( data );
              // simple validation
              if ( data.startOfImageMarker === 0xffd8 && data.identifier.includes( "JFIF" )) {
                  resultArea.innerText += "\n\nImage looks valid to me.";
              }
          } else {
              // EXAMPLE 2 : file is WAV audio file
              // first convert file into ByteArray (let's assume we will run into an error and need to do manual scanning, see below)
              const byteArray = await fileToByteArray( file );

              let { data, error }  = parseByteArray( byteArray, wavHeader );
              resultArea.innerText = error ? "An error has occurred during file parsing" : formatJson( data );

              // EXAMPLE 2.1 format not found. most likely file contains metadata which deviates from the WAV spec

              if ( ! data.formatName?.includes( "fmt" )) {
                  data = attemptWavCorrection( byteArray, data );
                  resultArea.innerText = formatJson( data ); // update existing view content
              }

              // simple validation
              if ( data.type === "RIFF" && data.format === "WAVE" && data.dataChunkId === "data" ) {
                  resultArea.innerText += "\n\nWave looks valid to me.";
              }

              // EXAMPLE 2.2 show how further data can be read
              findWavAudioBlock( byteArray, data );
          }
      });

      /* "advanced" examples */

      function attemptWavCorrection( byteArray, headerData ) {
          // try to find the "fmt " declaration within the ByteArray
          const formatNameOffset = scanUntil( byteArray, "fmt " );
          if ( formatNameOffset === Infinity ) {
              resultArea.innerText = "Could not find valid format declaration in WAV file. File is corrupted";
              return;
          }
          // attempt to read the parts of the header that failed to be read (this could be done more neatly, but you get the point...)
          const halfWavHeader = {
              formatName:       `${CHAR}[4]`, // should be "fmt " (note empty char!) but can be "JUNK"
              formatLength:     INT32,
              audioFormat:      INT16,
              channelAmount:    INT16,
              sampleRate:       INT32,
              bytesPerSecond:   INT32,
              blockAlign:       INT16,
              bitsPerSample:    INT16,
              dataChunkId:      `${CHAR}[4]`, // should be "data"
              dataChunkSize:    INT32
          };
          const secondAttempt = parseByteArray( byteArray, halfWavHeader, formatNameOffset );
          if ( secondAttempt.error ) {
              resultArea.innerText = "An error occurred during reattempted file parsing.";
              return;
          }
          // combine the separate headers into the "fixed" one
          return { ...headerData, ...secondAttempt.data };
      }

      function findWavAudioBlock( byteArray, headerData ) {
          const dataBlockStart = scanUntil( byteArray, headerData.dataChunkId, 0 );
          if ( dataBlockStart === Infinity ) {
              resultArea.innerText += "\nCould not find data block though.";
          } else {
              let dataType;
              switch ( headerData.bitsPerSample ) {
                  default:
                      dataType = 'FLOAT32'; // max 32-bit floating point
                      break;
                  case 16:
                      dataType = 'INT16';
                      break;
                  case 24:
                      dataType = 'INT24';
                      break;
              }
              // add size of Array and endianness to this data type (RIFF is always Little Endian)
              dataType = `${dataType}[${headerData.dataChunkSize}]|LE`;

              resultArea.innerText += `\nData block definition found at index ${dataBlockStart}.\n` +
              `Add the summed size of dataChunkId and dataChunkSize (8 bytes) to start reading the data from index ${dataBlockStart + 8}!\n` +
              `As the bit depth is ${headerData.bitsPerSample} and the RIFF format is Little Endian, you should parse for the "${dataType}" data-type.`;
          }
          // if you were interested in retrieving the audio data, you could do so like this:
          // const parsedData = parseByteArray( byteArray, { audio: dataType }, dataBlockStart + 8 );
          // console.warn(parsedData.data?.audio.slice( 0, 512 ));
      }</script></html>